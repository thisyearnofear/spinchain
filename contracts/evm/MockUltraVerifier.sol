// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/**
 * @title MockUltraVerifier
 * @notice Testnet-only mock of the Noir-generated UltraVerifier.
 *
 * The real UltraVerifier is generated by running:
 *   cd circuits/effort_threshold && nargo codegen-verifier
 *
 * For Fuji testnet / hackathon demos, this mock always returns true so you can
 * test the full reward flow before the ZK circuits are compiled.
 *
 * ⚠️  NEVER deploy this on mainnet — it accepts ANY proof as valid.
 */
contract MockUltraVerifier {
    /**
     * @notice Always returns true (mock verification).
     * @dev The real UltraVerifier signature is:
     *      function verify(bytes calldata proof, bytes32[] calldata publicInputs) external view returns (bool)
     */
    function verify(
        bytes calldata, /* proof */
        bytes32[] calldata /* publicInputs */
    ) external pure returns (bool) {
        return true;
    }
}
