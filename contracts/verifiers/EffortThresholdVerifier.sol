// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {Pausable} from "@openzeppelin/contracts/utils/Pausable.sol";

// UltraVerifier interface generated by Noir
interface IUltraVerifier {
    function verify(bytes calldata proof, bytes32[] calldata publicInputs) external view returns (bool);
}

/// @title EffortThresholdVerifier
/// @notice Verifies ZK proofs of effort on Avalanche C-Chain
/// @dev Integrates with SpinChain IncentiveEngine for reward distribution
/// @custom:security-contact security@spinchain.xyz
contract EffortThresholdVerifier is Ownable, Pausable {
    
    // ============ Errors ============
    error InvalidProof();
    error ProofAlreadyUsed();
    error InvalidPublicInputs();
    error ThresholdNotMet();
    error UnauthorizedCaller();
    error ArrayLengthMismatch();
    
    // ============ Events ============
    event ProofVerified(
        bytes32 indexed proofHash,
        address indexed rider,
        bytes32 indexed classId,
        uint16 effortScore,
        uint32 secondsAbove,
        uint256 timestamp
    );
    
    // ============ State ============
    
    /// @notice The underlying Noir verifier contract (upgradeable)
    IUltraVerifier public noirVerifier;
    
    /// @notice Authorized callers that can verify proofs
    mapping(address => bool) public authorizedCallers;
    
    /// @notice Tracks used proofs to prevent replay attacks
    mapping(bytes32 => bool) public usedProofs;
    
    /// @notice Verified proof data for audit trail
    struct VerifiedProof {
        address rider;
        bytes32 classId;
        uint16 effortScore;
        uint32 secondsAbove;
        uint256 timestamp;
        bool thresholdMet;
    }
    
    /// @notice Proof hash => verification details
    mapping(bytes32 => VerifiedProof) public proofDetails;
    
    // ============ Constructor ============
    
    constructor(address _noirVerifier) Ownable(msg.sender) {
        noirVerifier = IUltraVerifier(_noirVerifier);
        authorizedCallers[msg.sender] = true;
    }

    modifier onlyAuthorized() {
        if (!authorizedCallers[msg.sender]) revert UnauthorizedCaller();
        _;
    }
    
    // ============ Public Functions ============
    
    /// @notice Verify a ZK proof of effort (view only, no state change)
    function verifyProof(
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) external view whenNotPaused returns (bool success) {
        if (publicInputs.length != 7) revert InvalidPublicInputs();
        
        bool valid = noirVerifier.verify(proof, publicInputs);
        if (!valid) revert InvalidProof();
        
        bool thresholdMet = publicInputs[2] != bytes32(0);
        if (!thresholdMet) revert ThresholdNotMet();
        
        return true;
    }
    
    /// @notice Verify and record a proof (called by authorized contracts like IncentiveEngine)
    function verifyAndRecord(
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) external onlyAuthorized whenNotPaused returns (uint16 effortScore) {
        // Compute proof hash for replay protection
        bytes32 proofHash = keccak256(proof);
        
        // Check not already used
        if (usedProofs[proofHash]) {
            revert ProofAlreadyUsed();
        }
        
        // Verify
        bool valid = noirVerifier.verify(proof, publicInputs);
        if (!valid) {
            revert InvalidProof();
        }
        
        // Extract values from public inputs
        bool thresholdMet = publicInputs[2] != bytes32(0);
        uint32 secondsAbove = uint32(uint256(publicInputs[3]));
        effortScore = uint16(uint256(publicInputs[4]));
        bytes32 classId = publicInputs[5];
        address rider = address(uint160(uint256(publicInputs[6])));
        
        if (!thresholdMet) {
            revert ThresholdNotMet();
        }
        
        // Mark as used
        usedProofs[proofHash] = true;
        
        // Store details
        proofDetails[proofHash] = VerifiedProof({
            rider: rider,
            classId: classId,
            effortScore: effortScore,
            secondsAbove: secondsAbove,
            timestamp: block.timestamp,
            thresholdMet: true
        });
        
        emit ProofVerified(
            proofHash,
            rider,
            classId,
            effortScore,
            secondsAbove,
            block.timestamp
        );
        
        return effortScore;
    }
    
    /// @notice Batch verify multiple proofs (gas efficient)
    function batchVerify(
        bytes[] calldata proofs,
        bytes32[][] calldata publicInputsArray
    ) external onlyAuthorized whenNotPaused returns (uint16[] memory scores) {
        if (proofs.length != publicInputsArray.length) revert ArrayLengthMismatch();
        
        scores = new uint16[](proofs.length);
        
        for (uint i = 0; i < proofs.length; i++) {
            scores[i] = this.verifyAndRecord(proofs[i], publicInputsArray[i]);
        }
        
        return scores;
    }
    
    // ============ View Functions ============
    
    /// @notice Check if a proof has been used
    /// @param proofHash Hash of the proof
    function isProofUsed(bytes32 proofHash) external view returns (bool) {
        return usedProofs[proofHash];
    }
    
    /// @notice Get verification details for a proof
    /// @param proofHash Hash of the proof
    function getProofDetails(bytes32 proofHash) 
        external 
        view 
        returns (VerifiedProof memory) 
    {
        return proofDetails[proofHash];
    }
    
    /// @notice Get public inputs for a typical effort proof
    function encodePublicInputs(
        uint16 threshold,
        uint32 minDuration,
        bool thresholdMet,
        uint32 secondsAbove,
        uint16 effortScore,
        bytes32 classId,
        address rider
    ) external pure returns (bytes32[] memory) {
        bytes32[] memory inputs = new bytes32[](7);
        inputs[0] = bytes32(uint256(threshold));
        inputs[1] = bytes32(uint256(minDuration));
        inputs[2] = thresholdMet ? bytes32(uint256(1)) : bytes32(0);
        inputs[3] = bytes32(uint256(secondsAbove));
        inputs[4] = bytes32(uint256(effortScore));
        inputs[5] = classId;
        inputs[6] = bytes32(uint256(uint160(rider)));
        return inputs;
    }

    // ============ Admin ============

    function setNoirVerifier(address _noirVerifier) external onlyOwner {
        noirVerifier = IUltraVerifier(_noirVerifier);
    }

    function setAuthorizedCaller(address caller, bool authorized) external onlyOwner {
        authorizedCallers[caller] = authorized;
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }
}
