// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// UltraVerifier interface generated by Noir
// This would be generated by `nargo codegen-verifier`
interface IUltraVerifier {
    function verify(bytes calldata proof, bytes32[] calldata publicInputs) external view returns (bool);
}

/// @title EffortThresholdVerifier
/// @notice Verifies ZK proofs of effort on Avalanche C-Chain
/// @dev Integrates with SpinChain IncentiveEngine for reward distribution
contract EffortThresholdVerifier {
    
    // ============ Errors ============
    error InvalidProof();
    error ProofAlreadyUsed();
    error InvalidPublicInputs();
    error ThresholdNotMet();
    
    // ============ Events ============
    event ProofVerified(
        bytes32 indexed proofHash,
        address indexed rider,
        bytes32 indexed classId,
        uint16 effortScore,
        uint32 secondsAbove,
        uint256 timestamp
    );
    
    // ============ State ============
    
    /// @notice The underlying Noir verifier contract
    IUltraVerifier public immutable noirVerifier;
    
    /// @notice Tracks used proofs to prevent replay attacks
    mapping(bytes32 => bool) public usedProofs;
    
    /// @notice Verified proof data for audit trail
    struct VerifiedProof {
        address rider;
        bytes32 classId;
        uint16 effortScore;
        uint32 secondsAbove;
        uint256 timestamp;
        bool thresholdMet;
    }
    
    /// @notice Proof hash => verification details
    mapping(bytes32 => VerifiedProof) public proofDetails;
    
    // ============ Constructor ============
    
    constructor(address _noirVerifier) {
        noirVerifier = IUltraVerifier(_noirVerifier);
    }
    
    // ============ Public Functions ============
    
    /// @notice Verify a ZK proof of effort
    /// @param proof The Noir proof bytes
    /// @param publicInputs Array of public inputs:
    ///        [0] = threshold (u16)
    ///        [1] = min_duration (u32)
    ///        [2] = threshold_met (bool as bytes32)
    ///        [3] = seconds_above (u32)
    ///        [4] = effort_score (u16)
    ///        [5] = classId (bytes32)
    ///        [6] = rider (address as bytes32)
    /// @return success Whether verification succeeded
    function verifyProof(
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) external view returns (bool success) {
        // Validate input length
        if (publicInputs.length != 7) {
            revert InvalidPublicInputs();
        }
        
        // Verify using Noir verifier
        bool valid = noirVerifier.verify(proof, publicInputs);
        
        if (!valid) {
            revert InvalidProof();
        }
        
        // Check threshold was met
        bool thresholdMet = publicInputs[2] != bytes32(0);
        if (!thresholdMet) {
            revert ThresholdNotMet();
        }
        
        return true;
    }
    
    /// @notice Verify and record a proof (called by IncentiveEngine)
    /// @param proof The Noir proof bytes
    /// @param publicInputs Array of public inputs
    /// @return effortScore The calculated effort score (0-1000)
    function verifyAndRecord(
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) external returns (uint16 effortScore) {
        // Compute proof hash for replay protection
        bytes32 proofHash = keccak256(proof);
        
        // Check not already used
        if (usedProofs[proofHash]) {
            revert ProofAlreadyUsed();
        }
        
        // Verify
        bool valid = noirVerifier.verify(proof, publicInputs);
        if (!valid) {
            revert InvalidProof();
        }
        
        // Extract values from public inputs
        bool thresholdMet = publicInputs[2] != bytes32(0);
        uint32 secondsAbove = uint32(uint256(publicInputs[3]));
        effortScore = uint16(uint256(publicInputs[4]));
        bytes32 classId = publicInputs[5];
        address rider = address(uint160(uint256(publicInputs[6])));
        
        if (!thresholdMet) {
            revert ThresholdNotMet();
        }
        
        // Mark as used
        usedProofs[proofHash] = true;
        
        // Store details
        proofDetails[proofHash] = VerifiedProof({
            rider: rider,
            classId: classId,
            effortScore: effortScore,
            secondsAbove: secondsAbove,
            timestamp: block.timestamp,
            thresholdMet: true
        });
        
        emit ProofVerified(
            proofHash,
            rider,
            classId,
            effortScore,
            secondsAbove,
            block.timestamp
        );
        
        return effortScore;
    }
    
    /// @notice Batch verify multiple proofs (gas efficient)
    /// @param proofs Array of proof bytes
    /// @param publicInputsArray Array of public input arrays
    /// @return scores Array of effort scores
    function batchVerify(
        bytes[] calldata proofs,
        bytes32[][] calldata publicInputsArray
    ) external returns (uint16[] memory scores) {
        require(proofs.length == publicInputsArray.length, "Length mismatch");
        
        scores = new uint16[](proofs.length);
        
        for (uint i = 0; i < proofs.length; i++) {
            scores[i] = this.verifyAndRecord(proofs[i], publicInputsArray[i]);
        }
        
        return scores;
    }
    
    // ============ View Functions ============
    
    /// @notice Check if a proof has been used
    /// @param proofHash Hash of the proof
    function isProofUsed(bytes32 proofHash) external view returns (bool) {
        return usedProofs[proofHash];
    }
    
    /// @notice Get verification details for a proof
    /// @param proofHash Hash of the proof
    function getProofDetails(bytes32 proofHash) 
        external 
        view 
        returns (VerifiedProof memory) 
    {
        return proofDetails[proofHash];
    }
    
    /// @notice Get public inputs for a typical effort proof
    /// @param threshold Target heart rate
    /// @param minDuration Minimum seconds required
    /// @param thresholdMet Whether threshold was achieved
    /// @param secondsAbove Actual seconds above threshold
    /// @param effortScore Calculated effort score
    /// @param classId Class identifier
    /// @param rider Rider address
    function encodePublicInputs(
        uint16 threshold,
        uint32 minDuration,
        bool thresholdMet,
        uint32 secondsAbove,
        uint16 effortScore,
        bytes32 classId,
        address rider
    ) external pure returns (bytes32[] memory) {
        bytes32[] memory inputs = new bytes32[](7);
        inputs[0] = bytes32(uint256(threshold));
        inputs[1] = bytes32(uint256(minDuration));
        inputs[2] = thresholdMet ? bytes32(uint256(1)) : bytes32(0);
        inputs[3] = bytes32(uint256(secondsAbove));
        inputs[4] = bytes32(uint256(effortScore));
        inputs[5] = classId;
        inputs[6] = bytes32(uint256(uint160(rider)));
        return inputs;
    }
}
