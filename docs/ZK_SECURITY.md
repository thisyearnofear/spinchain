# SpinChain: ZK Integration & Security

## ZK Integration Guide

Complete guide for integrating Zero-Knowledge proofs into SpinChain.

---

### Overview

SpinChain uses **Noir** (Aztec's ZK language) to prove fitness effort without revealing sensitive health data. This guide covers circuit development, deployment, and usage.

---

### Quick Start

#### Prerequisites
```bash
# Install Noir
curl -L https://noirup.dev | bash
noirup

# Verify installation
nargo --version
```

#### Compile Circuits
```bash
cd circuits/effort_threshold

# Compile
nargo compile

# Run tests
nargo test

# Generate verifier contract
nargo codegen-verifier
```

---

### Circuit Details

#### `effort_threshold`

Proves that a rider maintained their heart rate above a threshold for a minimum duration.

**Private Inputs:**
```rust
heart_rates: [u16; 60],  // 60 seconds of HR data
num_points: u32,          // Actual data points used
```

**Public Inputs:**
```rust
threshold: u16,      // Target HR (e.g., 150)
min_duration: u32,   // Minimum seconds required
```

**Outputs:**
```rust
threshold_met: bool,    // Did they meet the goal?
seconds_above: u32,     // How many seconds above threshold
effort_score: u16,      // 0-1000 calculated score
```

#### Algorithm
```rust
for each heart_rate in heart_rates:
    if heart_rate > threshold:
        seconds_above += 1

threshold_met = seconds_above >= min_duration

// Effort score = (avg_effort / threshold) * 500
effort_score = min(1000, (avg_hr / threshold) * 500)
```

---

### Deployment

#### 1. Generate Verifier Contract

```bash
cd circuits/effort_threshold
nargo codegen-verifier

# Output: contract/effort_threshold/plonk_vk.sol
```

#### 2. Deploy to Avalanche

```solidity
// Deploy UltraVerifier (generated by Noir)
UltraVerifier ultraVerifier = new UltraVerifier();

// Deploy SpinChain verifier
EffortThresholdVerifier verifier = new EffortThresholdVerifier(
    address(ultraVerifier)
);
```

#### 3. Update Environment

```bash
# .env.local
NEXT_PUBLIC_EFFORT_VERIFIER_ADDRESS=0x...
```

---

### TypeScript Usage

#### Generate Proof

```typescript
import { useZKClaim } from '@/app/hooks/use-zk-claim';

function ClaimButton() {
  const { generateProof, submitProof, isGeneratingProof } = useZKClaim();

  const handleClaim = async () => {
    // Step 1: Generate ZK proof
    const proofResult = await generateProof(
      165,    // max heart rate achieved
      150,    // threshold
      10      // duration in minutes
    );

    if (!proofResult.success) {
      console.error(proofResult.error);
      return;
    }

    // Step 2: Submit to verifier
    await submitProof(
      {
        spinClass: '0x...',
        rider: '0x...',
        rewardAmount: '10',
        classId: '0x...',
      },
      proofResult.proof
    );
  };

  return (
    <button onClick={handleClaim} disabled={isGeneratingProof}>
      {isGeneratingProof ? 'Generating Proof...' : 'Claim Rewards'}
    </button>
  );
}
```

#### Check Privacy Score

```typescript
const { privacyScore, privacyLevel } = useZKClaim();

// privacyScore: 0-100
// privacyLevel: 'high' | 'medium' | 'low'

return (
  <div>
    Privacy: {privacyLevel} ({privacyScore}/100)
    {privacyLevel === 'high' && 'ðŸ”’ Minimal data revealed'}
  </div>
);
```

---

### Selective Disclosure

#### Create Custom Disclosure

```typescript
import { DisclosureBuilder, DEFAULT_POLICY } from '@/app/lib/zk/disclosure';

const disclosure = new DisclosureBuilder(DEFAULT_POLICY)
  .withProof(proof)
  .withStatement('Completed 30-minute endurance zone')
  .withMetadata({ duration: 30, zone: 'Endurance' })
  .build();

console.log(disclosure.statement);
// "Completed 30-minute endurance zone"

console.log(disclosure.revealed);
// { effortScore: 750, zone: 'Target', duration: 30 }

console.log(disclosure.hidden);
// { maxHeartRate: 0, avgPower: 0, rawDataPoints: 0 }
```

#### Privacy Policies

```typescript
// High privacy (default)
const HIGH_PRIVACY = {
  privateFields: ['heartRate', 'power', 'cadence', 'gps', 'biometrics'],
  revealableFields: ['effortScore', 'zone'],
  publicFields: ['classId', 'riderId', 'timestamp'],
};

// Medium privacy (competitions)
const MEDIUM_PRIVACY = {
  privateFields: ['heartRate', 'gps', 'biometrics'],
  revealableFields: ['effortScore', 'zone', 'duration', 'ranking'],
  publicFields: ['classId', 'riderId', 'timestamp'],
};
```

---

### Local Oracle

#### Session-Based Proving

```typescript
import { useLocalOracle } from '@/app/lib/zk/oracle';

function RideSession() {
  const { oracle, startSession, addTelemetry, endSession } = useLocalOracle();

  // Start ride
  const startRide = () => {
    startSession({
      classId: 'class-123',
      riderId: 'rider-456',
      startTime: Date.now(),
      targetHeartRate: 150,
      minDuration: 600, // 10 minutes
    });
  };

  // Add sensor data (called from WebSocket/Bluetooth)
  const onHeartRate = (hr: number) => {
    addTelemetry({
      timestamp: Date.now(),
      heartRate: hr,
      power: 200,
      cadence: 80,
    });
  };

  // End ride and generate proof
  const finishRide = async () => {
    const result = await endSession();

    if (result.success) {
      console.log('Proof generated:', result.proof);
      console.log('Effort score:', result.disclosure?.revealed.effortScore);
    }
  };
}
```

---

### Testing

#### Mock Prover (Development)

```typescript
import { getProver } from '@/app/lib/zk/prover';

const prover = getProver();
prover.setUseNoir(false); // Force mock

const proof = await prover.proveEffortThreshold(165, 150, 'class', 'rider', 10);
const valid = await prover.verify(proof);
// valid === true
```

#### Noir Prover (Production)

```bash
# Install packages
npm install @noir-lang/backend_barretenberg @noir-lang/noir_js

# Prover auto-detects Noir availability
const prover = getProver();
console.log(prover.getBackendInfo());
// { type: 'noir', available: true }
```

#### Circuit Compilation

```bash
# Install Noir CLI
curl -L https://noirup.dev | bash
noirup --version 1.0.0-beta.19

# Compile the circuit
cd circuits/effort_threshold
nargo compile

# Output: circuits/effort_threshold/target/effort_threshold.json
```

The compiled circuit is automatically copied to `public/circuits/effort_threshold/target/` for browser loading.

---

### Troubleshooting

#### "Circuit not found"
- Ensure `circuits/effort_threshold/target/` exists
- Run `nargo compile` to generate

#### "Noir packages not installed"
- Install: `npm install @noir-lang/backend_barretenberg @noir-lang/noir_js`
- Or use mock prover for development

#### "Proof verification failed"
- Check `NEXT_PUBLIC_EFFORT_VERIFIER_ADDRESS` is set
- Ensure verifier contract is deployed to correct network
- Verify proof hasn't been used before (replay protection)

#### "Gas estimation failed"
- ZK verification is gas-intensive (~200k gas)
- Ensure rider has sufficient AVAX

---

### Advanced Topics

#### Custom Circuits

To add a new circuit:

1. Create `circuits/my_circuit/`
2. Write `src/main.nr`
3. Add tests
4. Generate verifier
5. Deploy contract
6. Update `lib/zk/types.ts` with new CircuitType

#### Batch Verification

```solidity
// Verify multiple proofs in one transaction
bytes[] memory proofs = [proof1, proof2, proof3];
bytes32[][] memory inputs = [inputs1, inputs2, inputs3];

uint16[] memory scores = verifier.batchVerify(proofs, inputs);
```

#### Circuit Upgrades

1. Deploy new `UltraVerifier` contract
2. Update `EffortThresholdVerifier` to point to new verifier
3. Old proofs still valid (stored in `usedProofs`)

---

### Resources

- [Noir Documentation](https://noir-lang.org/)
- [UltraPlonk Paper](https://eprint.iacr.org/2022/1355)
- [Aztec Network](https://aztec.network/)
- [SpinChain Circuits](../circuits/)

---

## Security Considerations

### ZK Proof Security
- **Trusted Setup**: UltraPlonk uses universal SRS (no per-circuit setup).
- **Proof Replay**: Verifier contract tracks `usedProofs` mapping.
- **Front-running**: Commit-reveal scheme for claim submissions.

### Data Privacy
- **Local-First**: All biometric processing happens in browser.
- **Encrypted Backup**: Walrus storage uses rider-specific encryption.
- **Selective Disclosure**: Riders control exactly what is revealed.

### Contract Security
- **Upgradeable Verifier**: UltraVerifier can be upgraded for circuit improvements.
- **Access Control**: Only IncentiveEngine can call `verifyAndRecord`.
- **Emergency Pause**: Circuit breaker for verifier in case of bugs.

---

## BLE Fitness Equipment Integration Guide

### Overview
This integration enables your SpinChain web app to connect to Bluetooth Low Energy (BLE) fitness equipment like Schwinn IC4, Bowflex C6, and similar spin bikes that support the Fitness Machine Service (FTMS) protocol.

### Architecture Following Core Principles

#### 1. ENHANCEMENT FIRST
- Built upon existing responsive ride components
- Extended existing hook patterns (useTransaction â†’ useBleData)
- Enhanced UI components with BLE status indicators

#### 2. AGGRESSIVE CONSOLIDATION
- Single BLE service instance (singleton pattern)
- Centralized error handling and parsing
- Unified configuration in constants file

#### 3. PREVENT BLOAT
- Modular file structure with clear separation
- Only essential features included
- No unnecessary dependencies

#### 4. DRY (Don't Repeat Yourself)
- Single source of truth for BLE UUIDs and constants
- Reused error handling patterns
- Centralized type definitions

#### 5. CLEAN Separation of Concerns
- Service layer: `app/lib/ble/service.ts`
- Hook layer: `app/lib/hooks/use-ble-data.ts`
- Component layer: `app/components/ble/`
- Type layer: `app/lib/ble/types.ts`

#### 6. MODULAR Design
- Composable components and hooks
- Independent modules with clear interfaces
- Testable service layer

#### 7. PERFORMANT
- Efficient connection management
- Caching of device information
- Optimized data parsing

#### 8. ORGANIZED
- Domain-driven file structure
- Predictable naming conventions
- Clear import/export patterns

### File Structure

```
app/
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ ble/
â”‚   â”‚   â”œâ”€â”€ constants.ts      # BLE UUIDs and configuration
â”‚   â”‚   â”œâ”€â”€ service.ts        # Core BLE service (singleton)
â”‚   â”‚   â”œâ”€â”€ types.ts          # TypeScript interfaces
â”‚   â”‚   â””â”€â”€ parser.ts         # Data parsing utilities
â”‚   â””â”€â”€ hooks/
â”‚       â”œâ”€â”€ use-ble-data.ts   # Main BLE hook
â”‚       â””â”€â”€ ble.ts            # Hook exports
â”œâ”€â”€ components/
â”‚   â””â”€â”€ ble/
â”‚       â”œâ”€â”€ device-selector.tsx  # Device connection UI
â”‚       â””â”€â”€ index.ts             # Component exports
â””â”€â”€ rider/ride/[classId]/
    â””â”€â”€ enhanced-page.tsx        # BLE-integrated ride page
```

### Key Components

#### 1. BLE Service (`app/lib/ble/service.ts`)
- Singleton BLE connection manager
- Handles device scanning, connection, and data streaming
- Implements automatic reconnection
- Manages GATT service discovery

#### 2. useBleData Hook (`app/lib/hooks/use-ble-data.ts`)
- React hook following existing patterns
- Integrates with toast notifications
- Provides real-time metrics updates
- Handles connection state management

#### 3. DeviceSelector Component (`app/components/ble/device-selector.tsx`)
- UI component for device connection
- Visual feedback for connection status
- Real-time metrics display
- Error handling and recovery

#### 4. Enhanced Ride Page (`app/rider/ride/[classId]/enhanced-page.tsx`)
- Integration example showing BLE data in action
- Responsive design with device-specific layouts
- Real-time metrics overlay
- Slide-in device management panel

### Usage Examples

#### Basic Integration
```typescript
import { useBleData } from '@/lib/hooks/ble';

function MyComponent() {
  const {
    metrics,
    status,
    isConnected,
    scanAndConnect
  } = useBleData();

  return (
    <div>
      {isConnected && metrics && (
        <div>
          <p>Power: {metrics.power}W</p>
          <p>Heart Rate: {metrics.heartRate} BPM</p>
        </div>
      )}
      <button onClick={scanAndConnect}>
        Connect Device
      </button>
    </div>
  );
}
```

#### Advanced Integration with Error Handling
```typescript
import { useBleData } from '@/lib/hooks/ble';

function AdvancedComponent() {
  const {
    metrics,
    status,
    device,
    error,
    scanAndConnect,
    disconnect
  } = useBleData({
    autoConnect: false,
    onSuccess: (metrics) => {
      console.log('New metrics:', metrics);
      // Update your application state
    },
    onError: (error) => {
      console.error('BLE Error:', error);
      // Handle specific error cases
    }
  });

  // Render based on connection state
  if (status === 'connected') {
    return <ConnectedView metrics={metrics} device={device} onDisconnect={disconnect} />;
  }

  return <ConnectView onConnect={scanAndConnect} />;
}
```

### Supported Devices

The integration works with fitness equipment that supports:
- **Fitness Machine Service (FTMS)** - `00001826-0000-1000-8000-00805f9b34fb`
- **Cycling Power Service** - `00001818-0000-1000-8000-00805f9b34fb`
- **Heart Rate Service** - `0000180d-0000-1000-8000-00805f9b34fb`

Tested devices include:
- Schwinn IC4
- Bowflex C6
- Other FTMS-compatible equipment

### Browser Requirements

- **Chrome/Edge**: Full Web Bluetooth support
- **Safari**: Limited support (iOS 16+)
- **Firefox**: No Web Bluetooth support

### Error Handling

The system provides comprehensive error handling:
- Permission denied errors
- Device not found
- Connection failures
- Service/characteristic not found
- Data parsing errors

Errors are categorized and provide user-friendly messages through the existing toast system.

### Performance Considerations

- **Connection Management**: Efficient reconnection with exponential backoff
- **Data Updates**: Configurable update intervals (default: 1 second)
- **Memory Usage**: Proper cleanup of event listeners and intervals
- **Battery Optimization**: Smart scanning with timeout limits

### Testing

To test the integration:
1. Ensure you have a compatible BLE device
2. Use Chrome/Edge browser on desktop
3. Grant Bluetooth permissions when prompted
4. Test connection and data streaming

### Future Enhancements

Potential areas for expansion:
- Additional fitness equipment protocols
- Advanced metrics analysis
- Workout data logging and export
- Integration with fitness tracking services
- Multi-device support
- **Device Memory**: Automatically remember paired devices for quick reconnect
  - First connection: User selects device normally
  - Return visits: "Quick Connect" button appears for one-tap reconnection
  - Stored in localStorage (max 5 devices)
  - Works on Chrome Desktop with full Web Bluetooth support

### Troubleshooting

#### Common Issues:
1. **Device not found**: Ensure device is powered on and in pairing mode
2. **Connection fails**: Check browser compatibility and Bluetooth permissions
3. **No data**: Verify device supports required GATT services
4. **Performance issues**: Adjust update intervals in configuration

#### Debug Information:
Enable development mode to see detailed connection logs and device information in the component debug panel.

---

